CCS PCH C Compiler, Version 4.104, 5967               06-oct-15 01:02

               Filename: C:\Users\JAIME DIAZ\Desktop\LABORATORIOS UD\PROGRAMAS PIC\menu lcd\menu_lcd+kbd_4x4.lst

               ROM used: 1054 bytes (3%)
                         Largest free fragment is 31714
               RAM used: 13 (1%) at main() level
                         25 (1%) worst case
               Stack:    8 locations

*
0000:  GOTO   02E4
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include <THW-24G.h> 
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... //                        Laipac RF-24G / TXRX24G  
.................... //                   2.4GHz Wireless Transceiver Driver  
.................... //  
.................... // Original by micro222@yahoo.com  
.................... //  
.................... // Filename     : RF-24G_6-byte.c  
.................... // Programmer   : Steven Cholewiak, www.semifluid.com  
.................... // Version      : Version 1.01 - 01/30/2006  
.................... // Remarks      : Datasheets for RF-24G / TXRX24G are available from:  
.................... //                http://www.sparkfun.com/datasheets/RF/RF-24G_datasheet.pdf  
.................... //                http://www.sparkfun.com/datasheets/RF/RF-24G.pdf  
.................... //                http://www.sparkfun.com/datasheets/RF/nRF2401rev1_1.pdf  
.................... //                http://store.qkits.com/moreinfo.cfm/txrx24g.pdf  
.................... //  
.................... //                This code is modified from the original to support more  
.................... //                configuration options with more information provided about  
.................... //                each configuration byte.  
.................... //  
.................... // History      : Version 1.01 - 01/30/2006  
.................... //                - numOfBytes is now used to describe the packet payload and  
.................... //                  adjusts DATA1_W, DATA2_W, and BUF_MAX accordingly  
.................... //  
.................... //                Version 1.00 - 01/21/2006  
.................... //                - Initial release  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... //Pin Configuration  
.................... //  
.................... //    Pin   Name  Pin funtion Description  
.................... //    1     GND   Power       Gound (0V)  
.................... //    2     CE    Input       Chip Enable activates RX or TX mode  
.................... //    3     CLK2  I/O         Clock output/input for RX data channel 2  
.................... //    4     CS    Input       Chip Select activates Configuration mode  
.................... //    5     CLK1  I/O         Clock Input(TX)&I/O(RX) for data channel 1 3-wire interface  
.................... //    6     DATA  I/O         RX data channel 1/TX data input /3-wire interface  
.................... //    7     DR1   Output      RX data ready at data channel 1 (ShockBurst only)  
.................... //    8     DOUT2 Output      RX data channel 2  
.................... //    9     DR2   Output      RX data ready at data channel 2 (ShockBurst only)  
.................... //    10    VCC   Power       Power Supply (+3V DC)  
....................  
.................... #define RF_24G_CE       PIN_B3  
.................... #define RF_24G_DATA       PIN_B4  
.................... #define RF_24G_CLK1     PIN_B5  
.................... //#define RF_24G_CLK2     PIN_B0  
.................... #define RF_24G_DR1       PIN_B6  
.................... #define RF_24G_CS       PIN_B7  
.................... //#define RF_24G_DOUT2      PIN_B4  
.................... //#define RF_24G_DR2       PIN_B7  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define numOfBytes      6  
....................  
.................... #inline  
.................... RF_24G_initPorts() {  
....................    PORT_B_PULLUPS(FALSE);  
....................    DISABLE_INTERRUPTS(INT_RB);  
.................... }  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... //Configuration Bytes  
.................... //  
.................... //Bytes 14-02: Shockburst Configuration  
.................... //Bytes 01-00: General Device Configuration  
....................  
.................... //Byte 14: Length of data payload section RX channel 2 in bits  
.................... //    The total number of bits in a ShockBurst RF package may not exceed 256!  
.................... //    Maximum length of payload section is hence given by:  
.................... //    DATAx_W(bits) = 256 - ADDR_W - CRC  
.................... #define DATA2_W            numOfBytes * 8  
....................  
.................... //Byte 13: Length of data payload section RX channel 1 in bits  
.................... #define DATA1_W            numOfBytes * 8  
....................  
.................... //Byte 12-08: Channel 2 Address  
.................... #define ADDR2_4            0x00  
.................... #define ADDR2_3            0x00  
.................... #define ADDR2_2            0x00  
.................... #define ADDR2_1            0x42  
.................... #define ADDR2_0            0x42  
....................  
.................... //Byte 07-03: Channel 1 Address  
.................... #define ADDR1_4            0x00  
.................... #define ADDR1_3            0x00  
.................... #define ADDR1_2            0x00  
.................... #define ADDR1_1            0x42  
.................... #define ADDR1_0            0x42  
....................  
.................... //Byte 02  
.................... //    Bit 07-02: ADDR_W    - Number of address bits (both RX channels)  
.................... //                           Maximum number of address bits is 40 (5 bytes)  
.................... //    Bit    01: CRC_L     - 8 or 16 bits CRC  
.................... //    Bit    00: CRC_EN    - Enable on-chip CRC generation/checking  
.................... //    Combine (via |) together constants from each group  
.................... //                         0b76543210  
.................... #define ADDR_W_5_BYTE      0b10100000  
.................... #define ADDR_W_4_BYTE      0b10000000  
.................... #define ADDR_W_3_BYTE      0b01100000  
.................... #define ADDR_W_2_BYTE      0b01000000  
.................... #define ADDR_W_1_BYTE      0b00100000  
....................  
.................... #define CRC_L_8_BIT        0b00000000  
.................... #define CRC_L_16_BIT       0b00000010  
....................  
.................... #define CRC_EN_DISABLE     0b00000000  
.................... #define CRC_EN_ENABLE      0b00000001  
....................  
.................... //Byte 01  
.................... //    Bit    07: RX2_EN    - Enable two channel receive mode  
.................... //    Bit    06: CM        - Communication mode ( Direct or ShockBurst)  
.................... //    Bit    05: RFDR_SB   - RF data rate (1Mbps requires 16MHz crystal)  
.................... //    Bit 04-02: XO_F      - Crystal frequency (Factory default 16MHz crystal mounted)  
.................... //    Bit 01-00: RF_PWR    - RF output power  
.................... //    Combine (via |) together constants from each group  
.................... //                         0b76543210  
.................... #define RX2_EN_DISABLE     0b00000000  
.................... #define RX2_EN_ENABLE      0b10000000  
....................  
.................... #define CM_DIRECT          0b00000000  
.................... #define CM_SHOCKBURST      0b01000000  
....................  
.................... #define RFDR_SB_250_KBPS   0b00000000  
.................... #define RFDR_SB_1_MBPS     0b00100000  
....................  
.................... #define XO_F_4MHZ          0b00000000  
.................... #define XO_F_8MHZ          0b00000100  
.................... #define XO_F_12MHZ         0b00001100  
.................... #define XO_F_16MHZ         0b00001100  
.................... #define XO_F_20MHZ         0b00010000  
....................  
.................... #define RF_PWR_N20DB       0b00000000  // -20db  
.................... #define RF_PWR_N10DB       0b00000001  // -10db  
.................... #define RF_PWR_N5DB        0b00000010  // -5db  
.................... #define RF_PWR_0DB         0b00000011  // 0db (Full Power)  
....................  
.................... //Byte 01  
.................... //    Bit 07-01: RF_CH#    - Frequency channel (2400MHz + RF_CH# * 1.0MHz)  
.................... //    Bit    00: RXEN      - RX or TX operation  
.................... //    Combine (via |) together constants from each group  
.................... //                         0b76543210  
.................... #define RF_CH              0b10000000 // 64 - 2464GHz  
....................  
.................... #define RXEN_TX            0b00000000  
.................... #define RXEN_RX            0b00000001  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define BUF_MAX            numOfBytes  
.................... byte buf[BUF_MAX];  
.................... //#define CLKDELAY()         delay_us(1)  
.................... //#define CSDELAY()          delay_us(10)  
.................... //#define PWUPDELAY()        delay_ms(3)  
....................  
.................... void putByte( byte b ) {  //MSB bit first  
....................    int8 i;  
....................    int8 p = 7;  
....................    for(i=0 ; i < 8 ; i++) {  
....................       OUTPUT_LOW(RF_24G_CLK1);  
....................       if( BIT_TEST(b,p--) ) {  
....................          OUTPUT_HIGH(RF_24G_DATA);  
....................       }else{  
....................          OUTPUT_LOW(RF_24G_DATA);  
....................       }  
....................       //delay_us(1) ;  
....................       OUTPUT_HIGH(RF_24G_CLK1);  // Clock out on rising edge  
....................       //delay_us(1) ;  
....................    }  
.................... }  
....................  
.................... byte getByte() {  //MSB bit first  
....................    int8 i , b = 0;  
....................    int8 p = 7;  
....................    for(i=0 ; i < 8 ; i++) {  
....................       OUTPUT_LOW(RF_24G_CLK1);  
....................       //delay_us(1) ;  
....................       OUTPUT_HIGH(RF_24G_CLK1);  
....................       //delay_us(1) ;           // Read before falling edge  
....................       if( INPUT(RF_24G_DATA) ) {  
....................          BIT_SET(b,p--);  
....................       }else{  
....................          BIT_CLEAR(b,p--);  
....................       }  
....................    }  
....................    return b;  
.................... }  
....................  
.................... void RF_24G_Config() {  
....................    OUTPUT_LOW(RF_24G_CE);  
....................    OUTPUT_LOW(RF_24G_CS);  
....................    OUTPUT_LOW(RF_24G_CLK1);  
....................    OUTPUT_LOW(RF_24G_DATA);  
....................    //delay_ms(3) ;  
....................    OUTPUT_HIGH(RF_24G_CS);  
....................    //delay_us(10) ;  
....................  
....................    //MSB byte first  
....................    putByte(DATA2_W);  
....................    putByte(DATA1_W);  
....................    putByte(ADDR2_4);  
....................    putByte(ADDR2_3);  
....................    putByte(ADDR2_2);  
....................    putByte(ADDR2_1);  
....................    putByte(ADDR2_0);  
....................    putByte(ADDR1_4);  
....................    putByte(ADDR1_3);  
....................    putByte(ADDR1_2);  
....................    putByte(ADDR1_1);  
....................    putByte(ADDR1_0);  
....................    putByte(ADDR_W_2_BYTE | CRC_L_16_BIT | CRC_EN_ENABLE);  
....................    putByte(RX2_EN_DISABLE | CM_SHOCKBURST | RFDR_SB_1_MBPS | XO_F_16MHZ | RF_PWR_0DB);  
....................    putByte(RF_CH | RXEN_RX);  
....................  
....................    OUTPUT_FLOAT(RF_24G_DATA);  
....................    OUTPUT_LOW(RF_24G_CE);  
....................    OUTPUT_LOW(RF_24G_CS);  
....................    OUTPUT_LOW(RF_24G_CLK1);  
.................... }  
....................  
.................... void RF_24G_SetTxByte() {  
....................    OUTPUT_LOW(RF_24G_CE);  
....................    OUTPUT_HIGH(RF_24G_CS);  
....................    //delay_us(10) ;  
....................    putByte(RF_CH | RXEN_TX);  
....................    OUTPUT_LOW(RF_24G_CS);  
....................    OUTPUT_LOW(RF_24G_CLK1);  
.................... }  
....................  
.................... void RF_24G_SetTx() {  
....................    // Once the wanted protocol, modus and RF channel are set,  
....................    // only one bit (RXEN) is shifted in to switch between RX and TX.  
....................    OUTPUT_LOW(RF_24G_CE);  
....................    OUTPUT_HIGH(RF_24G_CS);  
....................    //delay_us(10) ;  
....................    OUTPUT_LOW(RF_24G_DATA);  
....................    OUTPUT_HIGH(RF_24G_CLK1);  
....................    //delay_us(1) ;  
....................    OUTPUT_LOW(RF_24G_CLK1);  
....................    //delay_us(1) ;  
....................    OUTPUT_LOW(RF_24G_CS);  
....................    OUTPUT_LOW(RF_24G_CLK1);  
.................... }  
....................  
.................... void RF_24G_SetRxByte() {  
....................    OUTPUT_LOW(RF_24G_CE);  
....................    OUTPUT_HIGH(RF_24G_CS);  
....................    //delay_us(10) ;  
....................    putByte(RF_CH | RXEN_RX);  
....................    OUTPUT_LOW(RF_24G_CS);  
....................    OUTPUT_FLOAT(RF_24G_DATA);  
....................    OUTPUT_LOW(RF_24G_CLK1);  
....................    OUTPUT_HIGH(RF_24G_CE);  
.................... }  
....................  
.................... void RF_24G_SetRx() {  
....................    // Once the wanted protocol, modus and RF channel are set,  
....................    // only one bit (RXEN) is shifted in to switch between RX and TX.  
....................    OUTPUT_LOW(RF_24G_CE);  
....................    OUTPUT_HIGH(RF_24G_CS);  
....................    //delay_us(10) ;  
....................    OUTPUT_HIGH(RF_24G_DATA);  
....................    OUTPUT_HIGH(RF_24G_CLK1);  
....................    //delay_us(1) ;  
....................    OUTPUT_LOW(RF_24G_CLK1);  
....................    //delay_us(1) ;  
....................    OUTPUT_LOW(RF_24G_CS);  
....................    OUTPUT_FLOAT(RF_24G_DATA);  
....................    OUTPUT_LOW(RF_24G_CLK1);  
....................    OUTPUT_HIGH(RF_24G_CE);  
.................... }  
....................  
.................... void putBuffer() {  
....................    int8 i;  
....................    OUTPUT_HIGH(RF_24G_CE);  
....................    //delay_us(10) ;  
....................  
....................    putByte(ADDR1_1);  
....................    putByte(ADDR1_0);  
....................  
....................    for( i=0; i<BUF_MAX ; i++) {  
....................       putByte(buf[i]);  
....................    }  
....................    OUTPUT_LOW(RF_24G_CE);  
....................    OUTPUT_LOW(RF_24G_CLK1);  
.................... }  
....................  
.................... void getBuffer() {  
....................    int8 i;  
....................    for( i=0; i<BUF_MAX ; i++) {  
....................        buf[i] = getByte();  
....................    }  
....................    OUTPUT_LOW(RF_24G_CLK1);  
....................    OUTPUT_HIGH(RF_24G_CE);  
.................... }  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... //Example Setup:  
.................... //  
.................... //    RF_24G_initPorts();  
.................... //    RF_24G_Config();  
.................... //    RF_24G_SetRx();    // Switch to receive  
.................... //    buf[0] = 'A';  
.................... //    buf[1] = 'B';  // Not used  
.................... //    buf[2] = 'C';  // Not used  
.................... //    buf[3] = 'D';  // Not used  
.................... //  
.................... //    while(1) {  
.................... //       if(INPUT(RF_24G_DR1)){  
.................... //          getBuffer();   // Get packet  
.................... //          putc(buf[0]);  
.................... //       }  
.................... //  
.................... //  
.................... //       // Transmit RF  
.................... //       RF_24G_SetTx();     // switch to transmit  
.................... //       delay_ms(1);  
.................... //       putBuffer();      // send packet (buf)  
.................... //       delay_ms(1);      // won't go back to recieve without this  
.................... //       RF_24G_SetRx();     // switch back to receive  
.................... //       delay_ms(1);  
.................... //    }  
....................  
.................... #fuses HS,NOWDT,NOLVP 
.................... #use delay(clock= 20M) 
*
0096:  CLRF   FEA
0098:  MOVLW  10
009A:  MOVWF  FE9
009C:  MOVF   FEF,W
009E:  BZ    00BA
00A0:  MOVLW  06
00A2:  MOVWF  01
00A4:  CLRF   00
00A6:  DECFSZ 00,F
00A8:  BRA    00A6
00AA:  DECFSZ 01,F
00AC:  BRA    00A4
00AE:  MOVLW  7B
00B0:  MOVWF  00
00B2:  DECFSZ 00,F
00B4:  BRA    00B2
00B6:  DECFSZ FEF,F
00B8:  BRA    00A0
00BA:  RETLW  00
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
00E6:  MOVLW  0F
00E8:  ANDWF  F95,W
00EA:  IORLW  F0
00EC:  MOVWF  F95
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00EE:  BSF    F8C.2
....................    delay_cycles(1); 
00F0:  NOP   
....................    lcd_output_enable(1); 
00F2:  BSF    F8C.0
....................    delay_cycles(1); 
00F4:  NOP   
....................    high = lcd_read_nibble(); 
00F6:  RCALL  00DA
00F8:  MOVFF  01,17
....................        
....................    lcd_output_enable(0); 
00FC:  BCF    F8C.0
....................    delay_cycles(1); 
00FE:  NOP   
....................    lcd_output_enable(1); 
0100:  BSF    F8C.0
....................    delay_us(1); 
0102:  BRA    0104
0104:  BRA    0106
0106:  NOP   
....................    low = lcd_read_nibble(); 
0108:  RCALL  00DA
010A:  MOVFF  01,16
....................        
....................    lcd_output_enable(0); 
010E:  BCF    F8C.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0110:  MOVLW  0F
0112:  ANDWF  F95,W
0114:  MOVWF  F95
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0116:  SWAPF  17,W
0118:  MOVWF  00
011A:  MOVLW  F0
011C:  ANDWF  00,F
011E:  MOVF   00,W
0120:  IORWF  16,W
0122:  MOVWF  01
.................... } 
0124:  GOTO   012C (RETURN)
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
00DA:  MOVF   F83,W
00DC:  MOVWF  00
00DE:  SWAPF  00,W
00E0:  ANDLW  0F
00E2:  MOVWF  01
....................   #endif 
.................... } 
00E4:  RETLW  00
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
00BC:  SWAPF  17,W
00BE:  ANDLW  F0
00C0:  MOVWF  00
00C2:  MOVLW  0F
00C4:  ANDWF  F8C,W
00C6:  IORWF  00,W
00C8:  MOVWF  F8C
....................   #endif 
....................        
....................    delay_cycles(1); 
00CA:  NOP   
....................    lcd_output_enable(1); 
00CC:  BSF    F8C.0
....................    delay_us(2); 
00CE:  MOVLW  03
00D0:  MOVWF  00
00D2:  DECFSZ 00,F
00D4:  BRA    00D2
....................    lcd_output_enable(0); 
00D6:  BCF    F8C.0
.................... } 
00D8:  RETLW  00
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
....................    lcd_output_rs(0); 
*
0128:  BCF    F8C.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
012A:  BRA    00E6
012C:  MOVFF  01,16
0130:  BTFSC  01.7
0132:  BRA    012A
....................    lcd_output_rs(address); 
0134:  BCF    F8C.1
0136:  BTFSC  14.0
0138:  BSF    F8C.1
....................    delay_cycles(1); 
013A:  NOP   
....................    lcd_output_rw(0); 
013C:  BCF    F8C.2
....................    delay_cycles(1); 
013E:  NOP   
....................    lcd_output_enable(0); 
0140:  BCF    F8C.0
....................    lcd_send_nibble(n >> 4); 
0142:  SWAPF  15,W
0144:  MOVWF  16
0146:  MOVLW  0F
0148:  ANDWF  16,F
014A:  MOVFF  16,17
014E:  RCALL  00BC
....................    lcd_send_nibble(n & 0xf); 
0150:  MOVF   15,W
0152:  ANDLW  0F
0154:  MOVWF  16
0156:  MOVWF  17
0158:  RCALL  00BC
.................... } 
015A:  RETLW  00
....................  
.................... void lcd_init(void)  
.................... { 
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
015C:  MOVLW  0F
015E:  ANDWF  F95,W
0160:  MOVWF  F95
....................   #endif 
....................    lcd_enable_tris(); 
0162:  BCF    F95.0
....................    lcd_rs_tris(); 
0164:  BCF    F95.1
....................    lcd_rw_tris(); 
0166:  BCF    F95.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
0168:  BCF    F8C.1
....................    lcd_output_rw(0); 
016A:  BCF    F8C.2
....................    lcd_output_enable(0); 
016C:  BCF    F8C.0
....................      
....................    delay_ms(15); 
016E:  MOVLW  0F
0170:  MOVWF  10
0172:  RCALL  0096
....................    for(i=1;i<=3;++i) 
0174:  MOVLW  01
0176:  MOVWF  0C
0178:  MOVF   0C,W
017A:  SUBLW  03
017C:  BNC   018E
....................    { 
....................        lcd_send_nibble(3); 
017E:  MOVLW  03
0180:  MOVWF  17
0182:  RCALL  00BC
....................        delay_ms(5); 
0184:  MOVLW  05
0186:  MOVWF  10
0188:  RCALL  0096
....................    } 
018A:  INCF   0C,F
018C:  BRA    0178
....................      
....................    lcd_send_nibble(2); 
018E:  MOVLW  02
0190:  MOVWF  17
0192:  RCALL  00BC
....................    for(i=0;i<=3;++i) 
0194:  CLRF   0C
0196:  MOVF   0C,W
0198:  SUBLW  03
019A:  BNC   01B8
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
019C:  CLRF   03
019E:  MOVF   0C,W
01A0:  MOVFF  FF2,0D
01A4:  BCF    FF2.7
01A6:  RCALL  0004
01A8:  BTFSC  0D.7
01AA:  BSF    FF2.7
01AC:  MOVWF  0D
01AE:  CLRF   14
01B0:  MOVWF  15
01B2:  RCALL  0128
01B4:  INCF   0C,F
01B6:  BRA    0196
.................... } 
01B8:  GOTO   02FE (RETURN)
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
01BC:  DECFSZ 11,W
01BE:  BRA    01C2
01C0:  BRA    01C8
....................       address=LCD_LINE_TWO; 
01C2:  MOVLW  40
01C4:  MOVWF  12
....................    else 
01C6:  BRA    01CA
....................       address=0; 
01C8:  CLRF   12
....................       
....................    address+=x-1; 
01CA:  MOVLW  01
01CC:  SUBWF  10,W
01CE:  ADDWF  12,F
....................    lcd_send_byte(0,0x80|address); 
01D0:  MOVF   12,W
01D2:  IORLW  80
01D4:  MOVWF  13
01D6:  CLRF   14
01D8:  MOVWF  15
01DA:  RCALL  0128
.................... } 
01DC:  RETLW  00
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
01DE:  MOVF   0F,W
01E0:  XORLW  0C
01E2:  BZ    01EE
01E4:  XORLW  06
01E6:  BZ    01FE
01E8:  XORLW  02
01EA:  BZ    020A
01EC:  BRA    0214
....................       case '\f'   :  lcd_send_byte(0,1); 
01EE:  CLRF   14
01F0:  MOVLW  01
01F2:  MOVWF  15
01F4:  RCALL  0128
....................                      delay_ms(2); 
01F6:  MOVLW  02
01F8:  MOVWF  10
01FA:  RCALL  0096
....................                      break; 
01FC:  BRA    0220
....................                       
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01FE:  MOVLW  01
0200:  MOVWF  10
0202:  MOVLW  02
0204:  MOVWF  11
0206:  RCALL  01BC
0208:  BRA    0220
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
020A:  CLRF   14
020C:  MOVLW  10
020E:  MOVWF  15
0210:  RCALL  0128
0212:  BRA    0220
....................       
....................       default     : lcd_send_byte(1,c);     break; 
0214:  MOVLW  01
0216:  MOVWF  14
0218:  MOVFF  0F,15
021C:  RCALL  0128
021E:  BRA    0220
....................    } 
.................... } 
0220:  RETLW  00
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... //#include <KBD4x4_1.C> 
....................  
.................... #use standard_io(A)//configura el tria para que no joda con la conversion AD 
....................  
.................... enum funciones {hi,what,bye,bye2};//HOLA,QUETAL,CHAO,VEMOS  //Asigna un  valor a cada elemento 
....................                                  //HOLA=0,QUE TAL=1,CHAO=2,VEMOS= 
.................... void hola (void){    
....................   lcd_gotoxy(1,2); 
*
0242:  MOVLW  01
0244:  MOVWF  10
0246:  MOVLW  02
0248:  MOVWF  11
024A:  RCALL  01BC
....................   printf(lcd_putc, "HOLA"); 
024C:  MOVLW  18
024E:  MOVWF  FF6
0250:  MOVLW  00
0252:  MOVWF  FF7
0254:  RCALL  0222
....................  } 
0256:  GOTO   02BE (RETURN)
....................  
.................... void quetal (void){ 
....................   lcd_gotoxy(1,2); 
025A:  MOVLW  01
025C:  MOVWF  10
025E:  MOVLW  02
0260:  MOVWF  11
0262:  RCALL  01BC
....................   printf(lcd_putc, "QUE TAL"); 
0264:  MOVLW  1E
0266:  MOVWF  FF6
0268:  MOVLW  00
026A:  MOVWF  FF7
026C:  RCALL  0222
....................  } 
026E:  GOTO   02BE (RETURN)
....................  
.................... void chao (void){   
....................   lcd_gotoxy(1,2); 
0272:  MOVLW  01
0274:  MOVWF  10
0276:  MOVLW  02
0278:  MOVWF  11
027A:  RCALL  01BC
....................   printf(lcd_putc, "CHAO"); 
027C:  MOVLW  26
027E:  MOVWF  FF6
0280:  MOVLW  00
0282:  MOVWF  FF7
0284:  RCALL  0222
....................  } 
0286:  GOTO   02BE (RETURN)
....................  
.................... void vemos (void){ 
....................   lcd_gotoxy(1,2); 
028A:  MOVLW  01
028C:  MOVWF  10
028E:  MOVLW  02
0290:  MOVWF  11
0292:  RCALL  01BC
....................   printf(lcd_putc, "VEMOS"); 
0294:  MOVLW  2C
0296:  MOVWF  FF6
0298:  MOVLW  00
029A:  MOVWF  FF7
029C:  RCALL  0222
....................  } 
029E:  GOTO   02BE (RETURN)
....................  
.................... void run_func(int numfunc){   //Asignación de la función a realizar 
....................                               //viene dada por la variable "item" 
....................    switch(numfunc) { 
02A2:  MOVF   0C,W
02A4:  ADDLW  FC
02A6:  BC    02BE
02A8:  ADDLW  04
02AA:  GOTO   02C2
....................       case hi: 
....................          hola(); 
02AE:  BRA    0242
....................          break; 
02B0:  BRA    02BE
....................       case what: 
....................          quetal(); 
02B2:  BRA    025A
....................          break; 
02B4:  BRA    02BE
....................       case bye: 
....................          chao(); 
02B6:  BRA    0272
....................          break; 
02B8:  BRA    02BE
....................       case bye2: 
....................          vemos(); 
02BA:  BRA    028A
....................          break;    
02BC:  BRA    02BE
....................    } 
.................... } 
02BE:  GOTO   03F8 (RETURN)
....................  
.................... void main() { 
*
02E4:  CLRF   FF8
02E6:  BCF    FD0.7
02E8:  CLRF   FEA
02EA:  CLRF   FE9
02EC:  MOVF   FC1,W
02EE:  ANDLW  C0
02F0:  IORLW  0F
02F2:  MOVWF  FC1
02F4:  MOVLW  07
02F6:  MOVWF  FB4
02F8:  MOVLW  04
02FA:  MOVWF  0B
....................    char item;         //Variables de funciones 
....................    char n_menus = 4;   //Número de funciones 
....................  
....................    lcd_init();    
02FC:  BRA    015C
....................    printf(lcd_putc, "Buenas Tardes "); 
02FE:  MOVLW  32
0300:  MOVWF  FF6
0302:  MOVLW  00
0304:  MOVWF  FF7
0306:  RCALL  0222
....................    lcd_gotoxy(1,2); 
0308:  MOVLW  01
030A:  MOVWF  10
030C:  MOVLW  02
030E:  MOVWF  11
0310:  RCALL  01BC
....................    printf(lcd_putc, "profe Jacinto"); 
0312:  MOVLW  42
0314:  MOVWF  FF6
0316:  MOVLW  00
0318:  MOVWF  FF7
031A:  RCALL  0222
....................    delay_ms(2000) ; 
031C:  MOVLW  08
031E:  MOVWF  0C
0320:  MOVLW  FA
0322:  MOVWF  10
0324:  RCALL  0096
0326:  DECFSZ 0C,F
0328:  BRA    0320
....................    lcd_putc('\f'); 
032A:  MOVLW  0C
032C:  MOVWF  0F
032E:  RCALL  01DE
....................    printf(lcd_putc, "Laboratorio #4"); 
0330:  MOVLW  50
0332:  MOVWF  FF6
0334:  MOVLW  00
0336:  MOVWF  FF7
0338:  RCALL  0222
....................    lcd_gotoxy(1,2); 
033A:  MOVLW  01
033C:  MOVWF  10
033E:  MOVLW  02
0340:  MOVWF  11
0342:  RCALL  01BC
....................    printf(lcd_putc, "C. Digitales II"); 
0344:  MOVLW  60
0346:  MOVWF  FF6
0348:  MOVLW  00
034A:  MOVWF  FF7
034C:  RCALL  0222
....................    delay_ms(2000); 
034E:  MOVLW  08
0350:  MOVWF  0C
0352:  MOVLW  FA
0354:  MOVWF  10
0356:  RCALL  0096
0358:  DECFSZ 0C,F
035A:  BRA    0352
....................     lcd_putc('\f'); 
035C:  MOVLW  0C
035E:  MOVWF  0F
0360:  RCALL  01DE
....................  
....................   while (true) { 
....................    if (input(PIN_A0) == 1) {   //Detecta botón de selección 
0362:  BSF    F92.0
0364:  BTFSS  F80.0
0366:  BRA    037E
....................        item++;                  //Si pulsa aumenta la variable 
0368:  INCF   0A,F
....................        delay_ms(300);//Para evitar rebotes 
036A:  MOVLW  02
036C:  MOVWF  0C
036E:  MOVLW  96
0370:  MOVWF  10
0372:  RCALL  0096
0374:  DECFSZ 0C,F
0376:  BRA    036E
....................        lcd_putc('\f');     } 
0378:  MOVLW  0C
037A:  MOVWF  0F
037C:  RCALL  01DE
....................  
.................... if (item > (n_menus-1)) {   //Si la variable supera el número de... 
037E:  MOVLW  01
0380:  SUBWF  0B,W
0382:  SUBWF  0A,W
0384:  BZ    038A
0386:  BNC   038A
....................       item = 0; }                 //funciones la inicializa 
0388:  CLRF   0A
....................  
....................    switch (item) { 
038A:  MOVF   0A,W
038C:  ADDLW  FC
038E:  BC    03E6
0390:  ADDLW  04
0392:  GOTO   03FC
....................       case 0: 
....................         lcd_gotoxy(1,1); 
0396:  MOVLW  01
0398:  MOVWF  10
039A:  MOVWF  11
039C:  RCALL  01BC
....................         printf(lcd_putc, "1* HOLA"); 
039E:  MOVLW  70
03A0:  MOVWF  FF6
03A2:  MOVLW  00
03A4:  MOVWF  FF7
03A6:  RCALL  0222
....................         break; 
03A8:  BRA    03E6
....................       case 1: 
....................          lcd_gotoxy(1,1); 
03AA:  MOVLW  01
03AC:  MOVWF  10
03AE:  MOVWF  11
03B0:  RCALL  01BC
....................         printf(lcd_putc, "2* QUE TAL?"); 
03B2:  MOVLW  78
03B4:  MOVWF  FF6
03B6:  MOVLW  00
03B8:  MOVWF  FF7
03BA:  RCALL  0222
....................         break; 
03BC:  BRA    03E6
....................       case 2: 
....................          lcd_gotoxy(1,1); 
03BE:  MOVLW  01
03C0:  MOVWF  10
03C2:  MOVWF  11
03C4:  RCALL  01BC
....................         printf(lcd_putc, "3* CHAO"); 
03C6:  MOVLW  84
03C8:  MOVWF  FF6
03CA:  MOVLW  00
03CC:  MOVWF  FF7
03CE:  RCALL  0222
....................         break; 
03D0:  BRA    03E6
....................       case 3: 
....................          lcd_gotoxy(1,1); 
03D2:  MOVLW  01
03D4:  MOVWF  10
03D6:  MOVWF  11
03D8:  RCALL  01BC
....................         printf(lcd_putc, "4* VEMOS"); 
03DA:  MOVLW  8C
03DC:  MOVWF  FF6
03DE:  MOVLW  00
03E0:  MOVWF  FF7
03E2:  RCALL  0222
....................         break; 
03E4:  BRA    03E6
....................    } 
....................   if (input(PIN_A1) == 1)   //Si se pulsa el botón de selección 
03E6:  BSF    F92.1
03E8:  BTFSS  F80.1
03EA:  BRA    03F8
....................      {delay_ms(200);         // ANTIREBOTE 
03EC:  MOVLW  C8
03EE:  MOVWF  10
03F0:  RCALL  0096
....................      run_func(item);}      //se llama a la función correspondiente 
03F2:  MOVFF  0A,0C
03F6:  BRA    02A2
....................   } 
03F8:  BRA    0362
.................... } 
03FA:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   IESO FCMEN HS PLL12 CPUDIV4 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
